# Функции

Функции – это многократно используемые фрагменты программы. Они позволяют дать имя определённому блоку команд с тем, чтобы впоследствии запускать этот блок по указанному имени в любом месте программы и сколь угодно много раз. Это называется *вызовом* функции. Мы уже использовали много встроенных функций, как то `len` и `range`.

Функция – это, пожалуй, *наиболее* важный строительный блок любой нетривиальной программы (на любом языке программирования), поэтому в этой главе мы рассмотрим различные аспекты функций.

Функции определяются при помощи зарезервированного слова `def`. После этого слова *указывается* имя функции, за которым следует пара скобок, в которых можно указать имена некоторых переменных, и заключительное двоеточие в конце строки. Далее следует блок команд, составляющих функцию. На примере можно видеть, что на самом деле это очень просто:

Пример (сохраните как `function1.py`)

<pre><code class="lang-python">{% include "./programs/function1.py" %}</code></pre>

Вывод:

<pre><code>{% include "./programs/function1.txt" %}</code></pre>

**Как это работает**

Мы определили функцию с именем `say_hello`, используя описанный выше синтаксис. Эта функция не принимает параметров, поэтому в скобках не объявлены какие-либо переменные. Параметры функции – это некие входные данные, которые мы можем передать функции, чтобы получить соответствующий им результат.

Обратите внимание, что мы можем вызывать одну и ту же функцию много раз, а значит нет необходимости писать один и тот же код снова и снова.

## Параметры функций

Функции могут принимать параметры, т.е. некоторые значения, передаваемые функции для того, чтобы она что-либо *сделала* с ними. Эти параметры похожи на переменные, за исключением того, что значение этих переменных указывается при вызове функции, и во время работы функции им уже присвоены их значения.

Параметры указываются в скобках при объявлении функции и разделяются запятыми. Аналогично мы передаём значения, когда вызываем функцию. Обратите внимание на терминологию: имена, указанные в объявлении функции, называются *параметрами*, тогда как значения, которые вы передаёте в функцию при её вызове, – *аргументами*.

Пример (сохраните как `function_param.py`):

<pre><code class="lang-python">{% include "./programs/function_param.py" %}</code></pre>

Вывод:

<pre><code>{% include "./programs/function_param.txt" %}</code></pre>

**Как это работает**

Здесь мы определили функцию с именем `print_max`, которая использует два параметра с именами `a` и `b`. Мы находим наибольшее число с применением простого оператора `if..else` и выводим это число.

При первом вызове функции `print_max` мы напрямую передаём числа в качестве аргументов. Во втором случае мы вызываем функцию с переменными в качестве аргументов. `print_max(x, y)` назначает значение аргумента `x` параметру `a`, а значение аргумента `y` – параметру `b`. В обоих случаях функция `print_max` работает одинаково.

## Локальные переменные

При объявлении переменных внутри определения функции, они никоим образом не связаны с другими переменными с таким же именем за пределами функции – т.е. имена переменных являются *локальными* в функции. Это называется *областью видимости* переменной. Область видимости всех переменных ограничена блоком, в котором они объявлены, начиная с точки объявления имени.

Пример (сохраните как `function_local.py`)

<pre><code class="lang-python">{% include "./programs/function_local.py" %}</code></pre>

Вывод:

<pre><code>{% include "./programs/function_local.txt" %}</code></pre>

**Как это работает**

При первом выводе *значения*, присвоенного имени *x*, в первой строке функции Python использует значение параметра, объявленного в основном блоке, выше определения функции.

Далее мы назначаем `x` значение `2`. Имя `x` локально для нашей функции. Поэтому когда мы заменяем значение `x` в функции, `x`, объявленный в основном блоке, остаётся незатронутым.

Последним вызовом функции `print` мы выводим значение `x`, указанное в основном блоке, подтверждая таким образом, что оно не изменилось при локальном присваивании значения в ранее вызванной функции.

## Зарезервированное слово `global` {#global-statement}

Чтобы присвоить некоторое значение переменной, определённой на высшем уровне программы (т.е. не в какой-либо области видимости, как то функции или классы), необходимо указать Python, что её имя не локально, а *глобально* (global). Сделаем это при помощи зарезервированного слова `global`. Без применения зарезервированного слова `global` невозможно присвоить значение переменной, определённой за пределами функции.

Можно использовать уже существующие значения переменных, определённых за пределами функции (при условии, что внутри функции не было объявлено переменной с таким же именем). Однако, это не приветствуется, и его следует избегать, поскольку человеку, читающему текст программы, будет непонятно, где находится объявление переменной. Использование зарезервированного слова `global` достаточно ясно показывает, что переменная объявлена в самом внешнем блоке.

Пример (сохраните как `function_global.py`):

<pre><code class="lang-python">{% include "./programs/function_global.py" %}</code></pre>

Вывод:

<pre><code>{% include "./programs/function_global.txt" %}</code></pre>

**Как это работает**

Зарезервированное слово `global` используется для того, чтобы объявить, что `x` – это глобальная переменная, а значит, когда мы присваиваем значение имени `x` внутри функции, это изменение отразится на значении переменной `x` в основном блоке программы.

Используя одно зарезервированное слово `global`, можно объявить сразу несколько переменных: `global x, y, z`.

## Значения аргументов по умолчанию {#default-arguments}

Зачастую часть параметров функций могут быть *необязательными*, и для них будут использоваться некоторые заданные значения по умолчанию, если пользователь не укажет собственных. Этого можно достичь с помощью значений аргументов по умолчанию. Их можно указать, добавив к имени параметра в определении функции оператор присваивания (`=`) с последующим значением.

Обратите внимание, что значение по умолчанию должно быть константой. Или точнее говоря, оно должно быть неизменным[^1] – это объясняется подробнее в последующих главах. А пока запомните это.

Пример (сохраните как `function_default.py`):

<pre><code class="lang-python">{% include "./programs/function_default.py" %}</code></pre>

Вывод:

<pre><code>{% include "./programs/function_default.txt" %}</code></pre>

**Как это работает**

Функция под именем `say` используется для вывода на экран строки указанное число раз. Если мы не указываем значения, по умолчанию строка выводится один раз. Мы достигаем этого указанием значения аргумента по умолчанию, равного `1` для параметра `times`[^2].

При первом вызове `say` мы указываем только строку, и функция выводит её один раз. При втором вызове `say` мы указываем также и аргумент `5`, обозначая таким образом, что мы хотим *сказать*[^3] фразу 5 раз.

> *ВАЖНО* 
>
> Значениями по умолчанию могут быть снабжены только параметры, находящиеся в конце списка параметров. 
> Таким образом, в списке параметров функции параметр со значением по умолчанию не может предшествовать параметру без значения по умолчанию. 
>
> Это связано с тем, что значения присваиваются параметрам в соответствии с их положением. Например,`def func(a, b=5)` допустимо, а `def func(a=5, b)` – *не допустимо*.

## Ключевые аргументы

Если имеется некоторая функция с большим числом параметров, и при её вызове требуется указать только некоторые из них, значения этих параметров могут задаваться по их имени – это называется *ключевые аргументы*. В этом случае для передачи аргументов функции используется имя (ключ) вместо позиции (как было до сих пор).

Есть два преимущества такого подхода: во-первых, использование функции становится легче, поскольку нет необходимости отслеживать порядок аргументов; во-вторых, можно задавать значения только некоторым избранным аргументам, при условии, что остальные параметры имеют значения аргумента по умолчанию.

Пример (сохраните как `function_keyword.py`):

<pre><code class="lang-python">{% include "./programs/function_keyword.py" %}</code></pre>

Вывод:

<pre><code>{% include "./programs/function_keyword.txt" %}</code></pre>

**Как это работает**

Функция с именем `func` имеет один параметр без значения по умолчанию, за которым следуют два параметра со значениями по умолчанию.

При первом вызове, `func(3, 7)`, параметр `a` получает значение `3`, параметр `b` получает значение `7`, а `c` получает своё значение по умолчанию, равное `10`.

При втором вызове `func(25, c=24)` переменная `a` получает значение `25` в силу позиции аргумента. После этого параметр `c` получает значение `24` по имени, т.е. как ключевой параметр. Переменная `b` получает значение по умолчанию, равное `5`.

При третьем обращении `func(c=50, a=100)` мы используем ключевые аргументы для всех указанных значений. Обратите внимание на то, что мы указываем значение для параметра `c` перед значением для `a`, даже несмотря на то, что в определении функции параметр `a` указан раньше `c`.

## Переменное число параметров

Иногда бывает нужно определить функцию, способную принимать _любое_ число параметров[^4]. Этого можно достичь при помощи звёздочек (сохраните как `function_varargs.py`):

<pre><code class="lang-python">{% include "./programs/function_varargs.py" %}</code></pre>

Вывод:

<pre><code>{% include "./programs/function_varargs.txt" %}</code></pre>

**Как это работает**

Когда мы объявляем параметр со звёздочкой (например, `*param`), все позиционные аргументы начиная с этой позиции и до конца будут собраны в кортеж под именем `param`.

Аналогично, когда мы объявляем параметры с двумя звёздочками (`**param`), все ключевые аргументы начиная с этой позиции и до конца будут собраны в словарь под именем `param`.

Мы изучим кортежи и словари в одной из [последующих глав](./data_structures.md#data-structures).

## Оператор `return` {#return-statement}

Оператор `return` используется для *возврата*[^5] из функции, т.е. для прекращения её работы и выхода из неё. При этом можно также *вернуть некоторое значение* из функции.

Пример (сохраните как `function_return.py`):

<pre><code class="lang-python">{% include "./programs/function_return.py" %}</code></pre>

Вывод:

<pre><code>{% include "./programs/function_return.txt" %}</code></pre>

**Как это работает**

Функция `maximum` возвращает максимальный из двух параметров, которые в данном случае передаются ей при вызове. Она использует обычный условный оператор `if..else` для определения наибольшего числа, а затем *возвращает* это число.

Обратите внимание, что оператор `return` без указания возвращаемого значения эквивалентен выражению `return None`. `None` – это специальный тип данных в Python, обозначающий ничего. К примеру, если значение переменной установлено в `None`, это означает, что ей не присвоено никакого значения.

Каждая функция содержит в неявной форме оператор `return None` в конце, если вы не указали своего собственного оператора `return`. В этом можно убедиться, запустив `print(some_function())`, где функция `some_function` – это какая-нибудь функция, не имеющая оператора `return` в явном виде. Например:

```python
def some_function():
    pass
```

Оператор `pass` используется в Python для обозначения пустого блока команд.

> ПРИМЕЧАНИЕ: Существует встроенная функция `max`, в которой уже реализован функционал 'поиск максимума', так что пользуйтесь этой встроенной функцией, где это возможно.

## DocStrings - Строки документации

Python имеет остроумную особенность, называемую *строками документации*, обычно обозначаемую сокращённо *docstrings*. Это очень важный инструмент, которым вы обязательно должны пользоваться, поскольку он помогает лучше документировать программу и облегчает её понимание. Поразительно, но строку документации можно получить, например, из функции, даже во время выполнения программы!

Пример (сохраните как `function_docstring.py`):

<pre><code class="lang-python">{% include "./programs/function_docstring.py" %}</code></pre>

Вывод:

<pre><code>{% include "./programs/function_docstring.txt" %}</code></pre>

**Как это работает**

Строка в первой логической строке функции является *строкой документации* для этой функции. Обратите внимание на то, что строки документации применимы также к [модулям](./modules.md#modules) и [классам](./oop.md#oop), о которых мы узнаем в соответствующих главах.

Строки документации принято записывать в форме многострочной[^7] строки, где первая строка начинается с заглавной буквы и заканчивается точкой. Вторая строка оставляется пустой, а подробное описание начинается с третьей. Вам *настоятельно рекомендуется* следовать такому формату для всех строк документации всех ваших нетривиальных функций.

Доступ к строке документации функции `print_max` можно получить с помощью атрибута этой функции (т.е. имени, принадлежащего ей) `__doc__` (обратите внимание на *двойное подчёркивание*). Просто помните, что Python представляет *всё* в виде объектов, включая функции. Мы узнаем больше об объектах в главе о [классах](./oop.md#oop).

Если вы пользовались функцией `help()` в Python, значит вы уже видели строки документации. Эта функция просто-напросто считывает атрибут `__doc__` соответствующей функции и аккуратно выводит его на экран. Вы можете проверить её на рассмотренной выше функции: просто включите `help(print_max)` в текст программы. Не забудьте нажать клавишу `q` для выхода из справки (`help`).

Точно так же автоматические инструменты могут получать документацию из программы. Именно поэтому я *настоятельно рекомендую* вам использовать строки документации для любой нетривиальной функции, которую вы пишете. Команда `pydoc`, поставляемая вместе с пакетом Python, работает аналогично функции `help()`.

## Резюме

Мы рассмотрели достаточно много аспектов функций, но тем не менее, вы должны понимать, что это далеко не все их аспекты. В то же время, мы охватили большинство того, с чем вы будете сталкиваться при повседневном использовании функций в Python.

Далее мы увидим, как использовать и создавать модули Python.

## Примечания

[^1] "immutable" в терминологии Python (прим. перев.)

[^2] times – англ. "раз" (прим. перев.)

[^3] say – англ. "сказать" (прим. перев.)

[^4] VarArgs – от англ. "Variable number of Arguments" – "переменное число аргументов" (прим. перев.)

[^5] return – англ. "возврат" (прим. перев.)

[^6] DocString - от англ. "Documentation String" – “строка документации” (прим. перев.)

[^7] т.е. строки, содержащей символы перевода строки. (прим. перев)
