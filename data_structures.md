# Структуры данных {#data-structures}

Структуры данных – это, по сути, и есть *структуры*, которые могут хранить некоторые *данные* вместе. Другими словами, они используются для хранения связанных данных.

В Python существуют четыре встроенных структуры данных: _список, кортеж, словарь и множество_. Посмотрим, как ими пользоваться, и как они могут облегчить нам жизнь.

## Список

`Список`[^1] – это структура данных, которая содержит упорядоченный набор элементов, т.е. хранит *последовательность* элементов. Это легко представить, если вспомнить список покупок, в котором перечисляется, что нужно купить, с тем лишь исключением, что в списке покупок каждый элемент обычно размещается на отдельной строке, тогда как в Python они разделяются запятыми.

Список элементов должен быть заключён в квадратные скобки, чтобы Python понял, что это список. Как только список создан, можно добавлять, удалять или искать элементы в нём. Поскольку элементы можно добавлять и удалять, мы говорим, что список – это *изменяемый* тип данных, т.е. его можно модифицировать.

## Краткое введение в объекты и классы

Хотя я и старался до сих пор оттянуть обсуждение объектов и классов, на данном этапе всё же необходимо некоторое пояснение, чтобы вы лучше поняли идею списков. Мы изучим эту тему детально в её [собственной главе](./oop.md#oop).

Список – это один из примеров использования объектов и классов. Когда мы назначаем некоторой переменной `i` значение, скажем, целое число `5`, это можно представить себе как создание *объекта* (т.е. экземпляра) `i` *класса* (т.е. типа) `int`. Чтобы лучше понять это, прочитайте `help(int)`.

Класс может также иметь *методы*, т.е. функции, определённые для использования только применительно к данному классу. Этот функционал будет доступен только когда имеется объект данного класса. Например, Python предоставляет метод `append` для класса `list`, который позволяет добавлять элемент к концу списка. Так `mylist.append('an item')` добавит эту строку к списку `mylist`. Обратите внимание на обозначение точкой для доступа к методам объектов.

Класс также может иметь *поля*, которые представляют собой не что иное, как переменные, определённые для использования только применительно к данному классу. Эти переменные/имена можно использовать только тогда, когда имеется объект этого класса. Доступ к полям также осуществляется при помощи точки. Например, `mylist.field`.

Пример (сохраните как `ds_using_list.py`):

<pre><code class="lang-python">{% include "./programs/ds_using_list.py" %}</code></pre>

Вывод:

<pre><code>{% include "./programs/ds_using_list.txt" %}</code></pre>

**Как это работает**

Переменная `shoplist` – это список покупок человека, идущего на рынок. В `shoplist` мы храним только строки с названиями того, что нужно купить, однако в список можно добавлять _любые объекты_, включая числа или даже другие списки.

Мы также использовали цикл `for..in` для итерации по элементам списка. Вы уже, наверное, поняли, что список является также и последовательностью. Особенности последовательностей будут рассмотрены [ниже](#sequence).

Обратите внимание на использование ключевого аргумента `end` в функции `print`, который показывает, что мы хотим закончить вывод пробелом вместо обычного перевода строки.

Далее мы добавляем элемент к списку при помощи `append` – метода объекта списка, который уже обсуждался ранее. Затем мы проверяем, действительно ли элемент был добавлен к списку, выводя содержимое списка на экран при помощи простой передачи этого списка функции `print`, которая аккуратно его печатает.

Затем мы сортируем список, используя метод `sort` объекта списка. Имейте в виду, что этот метод действует на сам список, а не возвращает изменённую его версию. В этом отличие от того, как происходит работа со строками. Именно это имеется в виду, когда мы говорим, что списки _изменяемы_, а строки – _неизменяемы_.

Далее после совершения покупки мы хотим удалить её из списка. Это достигается применением оператора `del`. Мы указываем, какой элемент списка мы хотим удалить, и оператор `del` удаляет его. Мы указываем, что хотим удалить первый элемент списка, и поэтому пишем `del shoplist[0]` (помните, что Python начинает отсчёт с 0).

Чтобы узнать более детально обо всех методах объекта списка, просмотрите `help(list)`.

## Кортеж

Кортежи служат для хранения нескольких объектов вместе. Их можно рассматривать как аналог списков, но без такой обширной функциональности, которую предоставляет класс списка. Одна из важнейших особенностей кортежей заключается в том, что они *неизменяемы*, так же, как и строки. Т.е. модифицировать кортежи невозможно.

Кортежи обозначаются указанием элементов, разделённых запятыми; по желанию их можно ещё заключить в круглые скобки.

Кортежи обычно используются в тех случаях, когда оператор или пользовательская функция должны наверняка знать, что набор значений, т.е. кортеж значений, не изменится.

Пример (сохраните как `ds_using_tuple.py`):

<pre><code class="lang-python">{% include "./programs/ds_using_tuple.py" %}</code></pre>

Вывод:

<pre><code>{% include "./programs/ds_using_tuple.txt" %}</code></pre>

**Как это работает**

Переменная `zoo` обозначает кортеж элементов. Как мы видим, функция `len` позволяет получить длину кортежа. Это также указывает на то, что кортеж является [последовательностью](#sequence).

Теперь мы перемещаем этих животных в новый зоопарк, поскольку старый зоопарк закрывается. Поэтому кортеж `new_zoo` содержит тех животных, которые уже там, наряду с привезёнными из старого зоопарка. Возвращаясь к реальности, обратите внимание на то, что кортеж внутри кортежа не теряет своей индивидуальности.

Доступ к элементам кортежа осуществляется указанием позиции элемента, заключённой в квадратные скобки – точно так же, как мы это делали для списков. Это называется оператором _индексирования_. Доступ к третьему элементу в `new_zoo` мы получаем, указывая `new_zoo[2]`, а доступ к третьему элементу внутри третьего элемента в кортеже `new_zoo` – указывая `new_zoo[2][2]`. Это достаточно просто, как только вы поймёте принцип.

> **Кортеж, содержащий 0 или 1 элемент**
>
> Пустой кортеж создаётся при помощи пустой пары скобок – `myempty = ()`. Однако, с кортежем из одного элемента не всё так просто. Его нужно указывать при помощи запятой после первого (и единственного) элемента, чтобы Python мог отличить кортеж от скобок, окружающих объект в выражении. Таким образом, чтобы получить кортеж, содержащий элемент `2`, вам потребуется указать `singleton = (2,)`.

<!-- -->

> **Замечание для программистов на Perl**
>
> Список внутри списка не теряет своей индивидуальности, т.е. списки не развёртываются, как в Perl. Это же относится к кортежу внутри кортежа, или кортежу внутри списка, или списку внутри кортежа и т.д. В Python все они рассматриваются как объекты, хранящиеся внутри другого объекта – только и всего.

## Словарь

Словарь – это некий аналог адресной книги, в которой можно найти адрес или контактную информацию о человеке, зная лишь его имя; т.е. некоторые *ключи* (имена) связаны со *значениями* (информацией). Заметьте, что ключ должен быть уникальным – вы ведь не сможете получить корректную информацию, если у вас записаны два человека с полностью одинаковыми именами.

Обратите также внимание на то, что в словарях в качестве ключей могут использоваться только неизменяемые объекты (как строки), а в качестве значений можно использовать как неизменяемые, так и изменяемые объекты. Точнее говоря, в качестве ключей должны использоваться только простые объекты.

Пары ключ-значение указываются в словаре следующим образом: `d = {key1 : value1, key2 : value2}`. Обратите внимание, что ключ и значение разделяются двоеточием, а пары друг от друга отделяются запятыми, а затем всё это заключается в фигурные скобки.

Помните, что пары ключ-значение никоим образом не упорядочены в словаре. Если вам необходим некоторый порядок, вам придётся отдельно отсортировать словарь перед обращением к нему.

Словари являются экземплярами/объектами класса `dict`.

Пример (сохраните как `ds_using_dict.py`):

<pre><code class="lang-python">{% include "./programs/ds_using_dict.py" %}</code></pre>

Вывод:

<pre><code>{% include "./programs/ds_using_dict.txt" %}</code></pre>

**Как это работает**

Мы создаём словарь `ab`[^2] при помощи обозначений, описанных ранее. Затем мы обращаемся к парам ключ-значение, указывая ключ в операторе индексирования, которым мы пользовались для списков и кортежей. Как видите, синтаксис прост.

Удалять пары ключ-значение можно при помощи нашего старого доброго оператора `del`. Мы просто указываем имя словаря и оператор индексирования для удаляемого ключа, после чего передаём это оператору `del`. Для этой операции нет необходимости знать, какое значение соответствует данному ключу.

Далее мы обращаемся ко всем парам ключ-значение нашего словаря, используя метод `items`, который возвращает список кортежей, каждый из которых содержит пару элементов: ключ и значение. Мы получаем эту пару и присваиваем её значение переменным `name` и `address` соответственно в цикле `for..in`, а затем выводим эти значения на экран в блоке for.

Новые пары ключ-значение добавляются простым обращением к нужному ключу при помощи оператора индексирования и присваиванием ему некоторого значения, как мы сделали для Guido в примере выше.

Проверить, существует ли пара ключ-значение, можно при помощи оператора `in`.

Чтобы просмотреть список всех методов класса `dict` смотрите `help(dict)`.

> **Ключевые Аргументы и Словари**
>
> К слову, если вы использовали ключевые аргументы в ваших функциях, вы уже использовали словари! Только подумайте: вы указали пару ключ-значение среди параметров функции при её определении, а когда обращаетесь к переменным внутри функции, то это, фактически, обращение по ключу к словарю (который в терминах разработчиков компиляторов называется _таблицей имён_).

## Последовательности

Списки, кортежи и строки являются примерами последовательностей. Но что такое последовательности и что в них такого особенного?

Основные возможности – это *проверка принадлежности* (т.е. выражения `in` и `not in`) и *оператор индексирования*, позволяющий получить напрямую некоторый элемент последовательности.

Все три типа последовательностей, упоминавшиеся выше (списки, кортежи и строки), также предоставляют операцию получения *среза*, которая позволяет получить срез последовательности, т.е. её фрагмент.

Пример (сохраните как `ds_seq.py`):

<pre><code class="lang-python">{% include "./programs/ds_seq.py" %}</code></pre>

Вывод:

<pre><code>{% include "./programs/ds_seq.txt" %}</code></pre>

**Как это работает**

Прежде всего, мы видим, как использовать индексы для получения отдельных элементов последовательности. Это ещё называют _приписыванием индекса_. Когда мы указываем число в квадратных скобках после последовательности, как показано выше, Python извлекает элемент, соответствующий указанной позиции в последовательности. Помните, что Python начинает отсчёт с 0. Поэтому `shoplist[0]` извлекает первый элемент, а `shoplist[3]` – четвёртый элемент последовательности `shoplist`.

Индекс также может быть отрицательным числом. В этом случае позиция отсчитывается от конца последовательности. Поэтому `shoplist[-1]` указывает на последний элемент последовательности `shoplist`, а `shoplist[-2]` – на предпоследний.

Операция вырезки производится при помощи указания имени последовательности, за которым может следовать пара чисел, разделённых двоеточием и заключённых в квадратные скобки. Заметьте, как это похоже на операцию индексирования, которой мы пользовались до сих пор. Помните, что числа в скобках необязательны, тогда как двоеточие – обязательно.

Первое число (перед двоеточием) в операции среза указывает позицию, с которой срез должен начинаться, а второе число (после двоеточия) указывает, где срез должен закончиться. Если первое число не указано, Python начнёт срез с начала последовательности. Если пропущено второе число, Python закончит срез у конца последовательности. Обратите внимание, что полученный срез будет _начинаться_ с указанной начальной позиции, а _заканчиваться_ прямо перед указанной конечной позицией, т.е. начальная позиция будет включена в срез, а конечная – нет.

Таким образом, `shoplist[1:3]` возвращает срез из последовательности, начинающуюся с позиции 1, включает позицию 2, но останавливается на позиции 3, и поэтому возвращает *срез* из двух элементов. Аналогично, `shoplist[:]` возвращает копию всей последовательности.

Срез может осуществляться и с отрицательными значениями. Отрицательные числа обозначают позицию с конца последовательности. Например, `shoplist[:-1]` вернёт вырезку из последовательности, исключающую последний элемент, но содержащую все остальные.

Кроме того, можно также указать третий аргумент для среза, который будет обозначать _шаг_ среза (по умолчанию шаг среза равен 1):

```python
>>> shoplist = ['яблоки', 'манго', 'морковь', 'бананы']
>>> shoplist[::1]
['яблоки', 'манго', 'морковь', 'бананы']
>>> shoplist[::2]
['яблоки', 'морковь']
>>> shoplist[::3]
['яблоки', 'бананы']
>>> shoplist[::-1]
['бананы', 'морковь', 'манго', 'яблоки']
```

Обратите внимание на то, что когда шаг равен 2, мы получаем элементы, находящиеся на позициях 0, 2, ... Когда шаг равен 3, мы получаем элементы с позиций 0, 3, ... и т.д.

Попробуйте разные комбинации параметров среза, используя интерактивную оболочку интерпретатора Python, т.е. его командную строку, чтобы сразу видеть результат. Последовательности замечательны тем, что они дают возможность обращаться к кортежам, спискам и строкам одним и тем же способом!

## Множество

Множества – это _неупорядоченные_ наборы простых объектов. Они необходимы тогда, когда присутствие объекта в наборе важнее порядка или того, сколько раз данный объект там встречается.

Используя множества, можно осуществлять проверку принадлежности, определять, является ли данное множество подмножеством другого множества, находить пересечения множеств и так далее.

```python
>>> bri = set(['Бразилия', 'Россия', 'Индия'])
>>> 'Индия' in bri
True
>>> 'США' in bri
False
>>> bric = bri.copy()
>>> bric.add('Китай')
>>> bric.issuperset(bri)
True
>>> bri.remove('Россия')
>>> bri & bric # или bri.intersection(bric)
{'Бразилия', 'Индия'}
```

**Как это работает**

Если вы помните основы теории множеств из школы, то этот пример достаточно понятен. Но если нет, вы можете погуглить "теория множеств" и "диаграмма Венна", чтобы лучше понять наше использование множеств в Python.

## Ссылки

Когда мы создаём объект и присваиваем его переменной, переменная только _ссылается_ на объект, а не представляет собой этот объект! То есть имя переменной указывает на ту часть памяти компьютера, где хранится объект. Это называется *привязкой* имени к объекту.

Обычно вам не следует об этом беспокоиться, однако есть некоторый неочевидный эффект, о котором нужно помнить.

Пример (сохраните как `ds_reference.py`):

<pre><code class="lang-python">{% include "./programs/ds_reference.py" %}</code></pre>

Вывод:

<pre><code>{% include "./programs/ds_reference.txt" %}</code></pre>

**Как это работает**

Большая часть объяснения содержится в комментариях.

Помните, что если вам нужно сделать копию списка или подобной последовательности, или другого сложного _объекта_ (не такого простого объекта, как целое число), вам следует воспользоваться операцией среза. Если вы просто присвоите имя переменной другому имени, оба они будут ссылаться на один и тот же объект, а это может привести к проблемам, если вы не осторожны.

> **Примечание для программистов на Perl**.
> 
> Помните, что оператор присваивания для списков **не** создает копию. Для создания копии последовательности необходимо использовать операцию среза.

## Ещё о строках {#more-strings}

Мы уже детально обсуждали строки ранее. Что же ещё можно о них узнать? Что ж, вы знали, например, что строки также являются объектами и имеют методы, при помощи которых можно делать практически всё: от проверки части строки до удаления краевых пробелов? На самом деле, вы уже использовали строковый метод... метод `format`!

Все строки, используемые вами в программах, являются объектами класса `str`. Некоторые полезные методы этого класса продемонстрированы на примере ниже. Чтобы посмотреть весь список методов, выполните `help(str)`.

Пример (сохраните как `ds_str_methods.py`):

<pre><code class="lang-python">{% include "./programs/ds_str_methods.py" %}</code></pre>

Вывод:

<pre><code>{% include "./programs/ds_str_methods.txt" %}</code></pre>

**Как это работает**

Здесь мы видим сразу несколько методов строк в действии. Метод `startswith` служит для того, чтобы определять, начинается ли строка с некоторой заданной подстроки. Оператор `in` используется для проверки, является ли некоторая строка частью данной строки.

Метод `find` используется для определения позиции данной подстроки в строке; `find` возвращает -1, если подстрока не обнаружена. В классе `str` также имеется отличный метод для объединения `(join)`[^3] элементов последовательности с указанной строкой в качестве разделителя между элементами, возвращающий большую строку, сгенерированную таким образом.

## Резюме

Мы детально рассмотрели различные встроенные структуры данных Python. Эти структуры данных будут крайне важны для написания программ существенного размера.

Теперь, когда мы накопили достаточно базовых знаний о Python, далее посмотрим, как проектировать и писать настоящую программу на Python.

## Примечания

[^1] list – англ. "список" (прим.перев.)

[^2] address book – англ. "адресная книга" (прим. перев.)

[^3] join – англ. "объединять" (прим.перев.)
