# Решение задач

Мы рассмотрели различные части языка Python, и теперь посмотрим, как все эти части работают вместе, проектируя и составляя программу, которая _делает_ что-то полезное. Цель состоит в том, чтобы научиться писать сценарии на языке Python самостоятельно.

## Задача

Перед нами стоит следующая задача:

> Составить программу, которая создаёт резервные копии всех наших важных файлов.

Хотя задача и проста, информации явно недостаточно, чтобы приступать к её решению. Необходим некоторый дополнительный *анализ*. Например, как мы выберем, _какие_ файлы необходимо копировать? _Как_ их хранить? _Где_ их хранить?

После надлежащего анализа мы *проектируем* нашу программу. Мы создаём список, описывающий то, как наша программа должна работать. В данном случае я создал список того, как я себе представляю её работу. Когда вы проектируете программу, у вас может получиться другой результат, поскольку каждый человек представляет себе это по-своему, так что это в порядке вещей.

- Файлы и каталоги, которые необходимо скопировать, собираются в список.
- Резервные копии должны храниться в основном каталоге резерва.
- Файлы помещаются в zip-архив.
- Именем для zip-архива служит текущая дата и время.
- Будем использовать стандартную команду `zip`, имеющуюся по умолчанию в любом стандартном дистрибутиве GNU/Linux. Обратите внимание, что для этого подойдёт любая команда архивации, если у неё есть интерфейс командной строки, чтобы ей можно было передавать аргументы из нашего сценария.

> **Для пользователей Windows**
> 
> Пользователи Windows могут [установить](http://gnuwin32.sourceforge.net/downlinks/zip.php) её со [страницы проекта GnuWin32](http://gnuwin32.sourceforge.net/packages/zip.htm) и добавить `C:\Program Files\GnuWin32\bin` к системной переменной окружения `PATH`, аналогично тому, как [мы это делали для самой команды python](./installation.md#dos-prompt).

## Решение

Как только проект программы более-менее устоялся, можно приступать к написанию кода, который и будет являться *реализацией* нашего решения.

Сохраните как `backup_ver1.py`:

<pre><code class="lang-python">{% include "./programs/backup_ver1.py" %}</code></pre>

Вывод:

<pre><code>{% include "./programs/backup_ver1.txt" %}</code></pre>

Теперь наступает стадия *тестирования*, когда мы проверяем, правильно ли работает наша программа. Если она работает не так, как ожидалось, нам придётся заняться её *отладкой* (дебагом)[^1], т.е. устранением *багов* (ошибок) в программе.

Если приведенная выше программа не работает, скопируйте строку, напечатанную после строки `Zip команда:` в выводе, вставьте ее в командную строку (в GNU/Linux и Mac OS X) / `cmd` (в Windows), посмотрите, в чем заключается ошибка, и попытайтесь ее исправить. Если она не срабатывает, проверьте справку по команде zip, чтобы выяснить, в чём может быть проблема. Если команда выполнится, проверьте, совпадает ли ваша программа на Python в точности с программой, приведённой выше.

**Как это работает**

Вы заметили, как мы превратили наш *проект* в *код* шаг за шагом.

Мы использовали модули `os` и `time`, предварительно импортировав их. Далее мы указали файлы и каталоги для резервного копирования в списке `source`[^2]. Каталог назначения – это каталог, в котором мы сохраняем все резервные копии, и он указывается в переменной `target_dir`. Именем zip-архива, который мы создаём, будет текущая дата и время, которые генерируются при помощи функции `time.strftime()`. У него будет расширение `.zip`, и храниться он будет в каталоге `target_dir`.

Обратите внимание на употребление переменной `os.sep` – она содержит разделитель пути для конкретной операционной системы, т.е. он будет `'/'` в GNU/Linux и Unix[^3], `'\\'` в Windows. Использование `os.sep` вместо этих символов напрямую делает программу переносимой, и она сможет работать на всех этих операционных системах.

Функция `time.strftime()` принимает в качестве аргумента формат вывода времени, например, такой, как мы указали в программе выше. Символ формата `%Y` будет замещён годом и столетием. Символ `%m` будет замещён месяцем в форме числа от `01` до `12`, и так далее. Полный список таких символов формата можно найти в [справочнике по Python](http://docs.python.org/3/library/time.html#time.strftime).

Имя конечного zip-файла мы создаём при помощи оператора, который _соединяет_ строки, т.е. объединяет две строки и возвращает новую. После этого мы создаём строку `zip_command`, которая содержит команду, которую мы намерены выполнить. Проверить, работает ли эта команда, можно запустив её отдельно в командной оболочке (терминал в GNU/Linux или командная строка DOS).

Команда `zip`, которую мы используем, имеет некоторые параметры. Параметр `-r` обозначает, что команда архивации должна работать **р**екурсивно[^4] для каталогов, т.е. должна включать все подкаталоги и файлы. За параметрами следует имя создаваемого zip-архива, за которым указывается список файлов и каталогов для резервного копирования. Мы превращаем список `source` в строку, используя уже знакомый нам метод `join`.

Затем мы, наконец, *выполняем* команду при помощи функции `os.system`, которая запускает команду так, как будто она была запущена из *системы*, т.е. из командной оболочки. Она возвращает `0`, если команда выполнена успешно, в противном случае она возвращает код ошибки.

В зависимости от вывода команды, мы печатаем соответствующее сообщение о том, успешным было создание резервных копий или нет.

Вот и всё, мы создали сценарий для сохранения резервных копий наших важных файлов!

> **Замечание для пользователей Windows**
>
> Вместо управляющей последовательности для обратной наклонной черты могут использоваться "сырые"[^5] строки. Например, можно писать `C:\\Documents` или `r'C:\Documents'`. Однако, не используйте `'C:\Documents'`, так как в этом случае окажется, что вы пытаетесь применить неизвестную управляющую последовательность `\D`.

Теперь, когда у нас есть рабочий сценарий резервного копирования, мы можем использовать его для создания копий наших файлов. Это называется *операционной* фазой или *развёртыванием* программы.

Программа, приведённая выше, работает корректно, но (обычно) поначалу программы не работают так, как вы того ожидаете. Проблемы могут возникать вследствие неправильного проектирования программы, допущения ошибки при наборе программного кода и т.д. В таких случаях приходится возвращаться к стадии проектирования или отладки программы.

## Вторая версия

Первая версия нашего сценария работает. Тем не менее, его можно улучшить так, чтобы было удобнее пользоваться в повседневной работе. Это называется стадией *поддержки* программы.

Одно из улучшений, показавшееся мне полезным, – это лучший механизм именования файлов: использование _времени_ в качестве имени файла, сохраняющегося в каталог с текущей _датой_ в качестве имени, который в свою очередь, расположен в главном каталоге для хранения резервных копий. Первое достоинство этого состоит в том, что копии хранятся в иерархической структуре, которой легче управлять. Второе достоинство – в том, что имена файлов намного короче. Третье достоинство состоит в том, что по именам каталогов можно легко определить, в какие дни создавались резервные копии, так как каталог создаётся только в случае резервного копирования данных в этот день.

Сохраните как `backup_ver2.py`:

<pre><code class="lang-python">{% include "./programs/backup_ver2.py" %}</code></pre>

Вывод:

<pre><code>{% include "./programs/backup_ver2.txt" %}</code></pre>

**Как это работает**

Большая часть программы осталась прежней. Разница в том, что теперь мы проверяем, существует ли каталог с именем, соответствующем текущей дате, внутри главного каталога для хранения резервных копий. Для этого мы используем функцию `os.path.exists`. Если он не существует, мы создаём его функцией `os.mkdir`.

## Третья версия

Вторая версия уже удобнее для работы с большим количеством резервных копий. С другой стороны, когда их много, становится трудно отличить, какая копия для чего. Например, мы могли внести значительные изменения в какую-то программу или презентацию, и теперь хотим указать суть этих изменений в имени zip-архива. Этого легко можно достичь добавлением пользовательского комментария к имени zip-архива.

ПРИМЕЧАНИЕ: Следующая программа не работает, так что не переживайте, просто проследуйте по ней, так как в ней содержится урок.

Сохраните как `backup_ver3.py`:

<pre><code class="lang-python">{% include "./programs/backup_ver3.py" %}</code></pre>

Вывод:

<pre><code>{% include "./programs/backup_ver3.txt" %}</code></pre>

**Как это (не) работает**

*Эта программа не работает!* Python сообщает об обнаружении ошибки синтаксиса, что означает, что сценарий не удовлетворяет структуре, которую ожидает увидеть Python. Когда Python выдаёт сообщение об ошибке, он также указывает нам на место ошибки. Так что мы начинаем *отладку* программы с этой строки.

При внимательном рассмотрении, мы видим, что одна логическая строка была разбита на две физические строки, но мы не указали, что эти две физические строки являются частью одной. На деле же Python просто обнаружил оператор сложения (`+`) без соответствующего операнда в той же логической строке, а поэтому не знает, как продолжать. Помните, что мы можем указать, что логическая строка продолжается на следующей физической при помощи обратной наклонной черты в конце физической строки. Внесём это исправление в нашу программу. Коррекция программы при обнаружении ошибок и называется *отладкой*[^6].

## Четвёртая версия

Сохраните как `backup_ver4.py`:

<pre><code class="lang-python">{% include "./programs/backup_ver4.py" %}</code></pre>

Вывод:

<pre><code>{% include "./programs/backup_ver4.txt" %}</code></pre>

**Как это работает**

Теперь эта программа работает! Давайте просмотрим все улучшения, сделанные нами для версии 3. Мы запрашиваем пользовательский комментарий при помощи функции `input`, а затем проверяем, ввёл ли пользователь что-либо, определяя длину введённой строки функцией `len`. Если пользователь просто нажал `enter`, не вводя никакого текста (может быть, это было регулярное создание резервной копии, или никаких особых изменений внесено не было), мы продолжаем так же, как делали до сих пор.

Если же комментарий был введён, он добавляется к имени zip-архива перед расширением `.zip`. Обратите внимание, что мы заменяем пробелы в комментарии подчёркиваниями: управлять файлами без пробелов в именах намного легче.

## Дополнительные усовершенствования

Четвёртая версия – вполне удовлетворительный рабочий сценарий для большинства пользователей, однако нет пределов совершенства. Например, в программу можно добавить уровень _подробности_[^7] вывода, чтобы при указании параметра `-v` она становилась более "разговорчивой" или параметр `-q` чтобы сделать это _тихо_[^8].

Ещё одним возможным улучшением была бы возможность передавать сценарию другие файлы и каталоги прямо в командной строке. Эти имена можно получать из списка `sys.argv` и добавлять к нашему списку `source` при помощи метода `extend` класса `list`.

Наиболее важным усовершенствованием было бы прекращение использования `os.system` для создания архивов, а применение вместо него встроенных модулей [zipfile](http://docs.python.org/3/library/zipfile.html) или [tarfile](http://docs.python.org/3/library/tarfile.html). Они являются частью стандартной библиотеки, поэтому всегда доступны для использования без зависимости от внешней программы zip на компьютере.

В приведённых примерах мы использовали способ с `os.system` для создания резервных копий исключительно в педагогических целях, чтобы пример был достаточно прост для понимания любым читателем, но достаточно реален для того, чтобы делать что-то полезное.

Попробуйте написать пятую версию с использованием модуля [zipfile](http://docs.python.org/3/library/zipfile.html) вместо вызова `os.system`.

## Процесс разработки программного обеспечения

В процессе создания программы мы прошли через несколько *стадий*. Эти стадии можно свести примерно в такой список:

1. Что (Анализ)
2. Как (Проектирование)
3. Создание (Реализация)
4. Тестирование (Тестирование и Отладка)
5. Использование (Развёртывание и Оперирование)
6. Поддержка (Усовершенствование)

Процедура, которую мы прошли при написании сценария создания резервных копий рекомендуется и для других программ: Проведите анализ и проектирование. Начните реализацию с простейшей версии. Протестируйте и отладьте её. Попользуйтесь ею, чтобы убедиться, что она работает, как ожидалось. После этого добавляйте любые необходимые функции, повторяя цикл "Создание-Тестирование-Использование" столько раз, сколько потребуется.

Помните:

> Программы выращиваются, а не строятся.
> -- [Bill de hÓra](http://97things.oreilly.com/wiki/index.php/Great_software_is_not_built,_it_is_grown)

## Резюме

Мы увидели, как создавать свои собственные программы/сценарии на Python, а также различные стадии написания программ. На данном этапе вам будет полезно создать собственную программу по такому рецепту, как мы это делали в настоящей главе, чтобы лучше привыкнуть к Python, равно как и к решению задач.

Далее мы обсудим объектно-ориентированное программирование.

## Примечания

[^1]: debug – применительно к компьютерным программам обозначает отладку (обнаружение и устранение ошибок, которые при этом принято называть "bug", т.е. "жук"). По всей видимости, это берёт своё начало с процедуры изгнания насекомых из схем больших ЭВМ, хотя само понятие "bug" в смысле маленькой неисправности встречается и в более ранней литературе, например, в записях Томаса Эдисона 1878 года. (прим. перев.)

[^2]: source – англ. "источник" (прим.перев.)

[^3]: Под словом "Unix" здесь подразумеваются все операционные системы, построенные по принципам ОС Unix, а не только она сама по себе. Примерами таких операционных систем являются все дистрибутивы GNU/Linux, семейство ОС *BSD, Android, Solaris и т.д. (прим.перев.)

[^4]: recursive – англ. "рекурсивно" (прим.перев.)

[^5]: raw – англ. "сырой", "необработанный" (прим.перев)

[^6]: bug fixing – устранение "багов", исправление ошибок (прим.перев)

[^7]: verbosity – англ. "многословность". Применительно к компьютерным программам обозначает степень подробности выводимых программой сообщений, т.е. степень "разговорчивости" программы. Отсюда и название этого параметра (прим.перев)

[^4]: quiet – англ. "тихо" (прим.перев.)
