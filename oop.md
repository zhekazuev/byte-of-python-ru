# Объектно-ориентированное программирование {#oop}

До сих пор наши программы состояли из функций, т.е. блоков выражений, которые манипулируют данными. Это называется _процедурно-ориентированным_ стилем программирования. Существует и другой способ организации программ: объединять данные и функционал внутри некоего объекта. Это называется _объектно-ориентированной_ парадигмой программирования. В большинстве случаев можно ограничиться процедурным программированием, а при написании большой программы или если решение конкретной задачи того требует, можно переходить к техникам объектно-ориентированного программирования.

Два основных аспекта объектно-ориентированного программирования – классы и объекты. **Класс** создаёт новый _тип_, а **объекты** являются **экземплярами** класса. Аналогично, когда мы говорим о переменных типа `int`, это означает, что переменные, которые хранят целочисленные значения, являются экземплярами (объектами) класса `int`.

> **Замечание для Программистов на Статических Языках**
> 
> Обратите внимание, что даже целые числа рассматриваются как объекты (класса `int`), в отличие от C++ и Java (до версии 1.5), где целые числа являются примитивами.
>
> См. `help(int)` для более детального описания этого класса.
> 
> Программисты на C# и Java 1.5 могут заметить сходство с концепцией _упаковки и распаковки_(boxing and unboxing).

Объекты могут хранить данные в обычных переменных, которые _принадлежат_ объекту. Переменные, принадлежащие объекту или классу, называют **полями**. Объекты могут также обладать функционалом, т.е. иметь функции, _принадлежащие_ классу. Такие функции принято называть **методами** класса. Эта терминология важна, так как она помогает нам отличать независимые функции и переменные от тех, что принадлежат классу или объекту. Всё вместе (поля и методы) принято называть **атрибутами** класса.

Поля бывают двух типов: они могут принадлежать каждому отдельному экземпляру объекта класса или всему классу. Они называются **переменными экземпляра** и **переменными класса** соответственно.

Класс создаётся ключевым словом `class`. Поля и методы класса записываются в блоке кода с отступом.

## Параметр `self` {#self}

Методы класса имеют одно отличие от обычных функций: они должны иметь дополнительно имя, добавляемое к началу списка параметров. Однако, при вызове метода никакого значения этому параметру присваивать **не нужно** – его укажет Python. Эта переменная указывает на _сам_ объект экземпляра класса, и по традиции она называется `self`.

Хотя этому параметру можно дать любое имя, _настоятельно рекомендуется_ использовать только имя `self`; использование любого другого имени не приветствуется. Есть много достоинств использования стандартного имени: во-первых, любой человек, просматривающий вашу программу, легко узнает его; во-вторых, некоторые специализированные Интегрированные среды разработки (IDE - Integrated Development Environment) изначально рассчитаны на использование `self`.

> **Замечание для Программистов на C++, Java и C#**
> 
> `self` в Python эквивалентно указателю `this` в C++ и ссылке this в Java и C#.

Вы, должно быть, удивляетесь, как Python присваивает значение `self `и почему вам не нужно указывать это значение самостоятельно. Поясним это на примере. Предположим, у нас есть класс с именем `MyClass` и экземпляр этого класса с именем `myobject`. При вызове метода этого объекта, например, `myobject.method(arg1, arg2)`, Python автоматически превращает это в `MyClass.method(myobject, arg1, arg2)` – в этом и состоит смысл `self`.

Это также означает, что если какой-либо метод не принимает аргументов, у него всё равно будет один аргумент – `self`.

## Классы {#classes}

Простейший класс показан в следующем примере (сохраните как `oop_simplestclass.py`).

<pre><code class="lang-python">{% include "./programs/oop_simplestclass.py" %}</code></pre>

Вывод:

<pre><code>{% include "./programs/oop_simplestclass.txt" %}</code></pre>

**Как это работает**

Мы создаём новый класс при помощи оператора `class` и имени класса. За этим следует блок выражений, формирующих тело класса. В данном случае блок у нас пуст, на что указывает оператор `pass`.

Далее мы создаём объект-экземпляр класса, записывая имя класса со скобками. (Мы узнаем [больше о реализации](#init) в следующем разделе). Для проверки мы выясняем тип переменной, просто выводя её на экран. Так мы видим, что у нас есть экземпляр класса `Person` в модуле `__main__`.

Обратите внимание, что выводится также и адрес в памяти компьютера, где хранится ваш объект. На вашем компьютере адрес будет другим, так как Python хранит объекты там, где имеется свободное место.

## Методы

Итак, мы выяснили что классы/объекты могут иметь методы, представляющие собой функции, за исключением дополнительной переменной `self`. А теперь давайте рассмотрим пример (сохраните как `oop_method.py`).

<pre><code class="lang-python">{% include "./programs/oop_method.py" %}</code></pre>

Вывод:

<pre><code>{% include "./programs/oop_method.txt" %}</code></pre>

**Как это работает**

Здесь мы видим `self` в действии. Обратите внимание, что метод `say_hi` не принимает параметров, но тем не менее, имеет `self` в определении функции.

## Метод `__init__` {#init}

Существует много методов, играющих специальную роль в классах Python. Сейчас мы увидим значительность метода `__init__`.

Метод `__init__` запускается, как только объект класса реализуется (т.е. создан). Этот метод полезен для осуществления разного рода *инициализации* (т.е. передача начальных значений вашему объекту), необходимой для данного объекта. Обратите внимание на двойные подчёркивания в начале и в конце имени.

Пример (сохраните как `oop_init.py`):

<pre><code class="lang-python">{% include "./programs/oop_init.py" %}</code></pre>

Вывод:

<pre><code>{% include "./programs/oop_init.txt" %}</code></pre>

**Как это работает**

Здесь мы определяем метод `__init__` так, чтобы он принимал параметр `name` (наряду с обычным `self`). Далее мы создаём новое поле с именем `name`. Обратите внимание, что это две разные переменные, даже несмотря на то, что они обе названы 'name'. Это не проблема, так как точка в выражении `self.name` обозначает, что существует нечто с именем "name", являющееся частью объекта "self", и другое `name` – локальная переменная. Поскольку мы в явном виде указываем, к которому имени мы обращаемся, путаницы не возникнет.

Для создания нового экземпляра `p` класса `Person` мы указываем имя класса, после которого – аргументы в скобках: `p = Person('Swaroop')`.

Метод `__init__` мы при этом не вызываем явным образом. В этом и заключается специальная роль данного метода.

После этого мы получаем возможность использовать поле `self.name` в наших методах, что и продемонстрировано в методе `say_hi`.

## Переменные класса и объекта {#class-obj-vars}

Функциональную часть классов и объектов (т.е. методы) мы обсудили, теперь давайте ознакомимся с частью данных. Данные, т.е. поля, являются не чем иным, как обычными переменными, _заключёнными_ в **пространствах имён** классов и объектов. Это означает, что их имена действительны только в контексте этих классов или объектов. Отсюда и название _пространство имён_.

Существует два типа _полей_: переменные класса и переменные объекта, которые различаются в зависимости от того, _принадлежит_ ли переменная классу или объекту соответственно.

**Переменные класса** разделяемы – доступ к ним могут получать все экземпляры этого класса. Переменная класса существует только одна, поэтому когда любой из объектов изменяет переменную класса, это изменение отразится и во всех остальных экземплярах того же класса.

**Переменные объекта** принадлежат каждому отдельному экземпляру класса. В этом случае у каждого объекта есть своя собственная копия поля, т.е. не разделяемая и никоим образом не связанная с другими такими же полями в других экземплярах. Это легко понять на примере (сохраните как `oop_objvar.py`):

<pre><code class="lang-python">{% include "./programs/oop_objvar.py" %}</code></pre>

Вывод:

<pre><code>{% include "./programs/oop_objvar.txt" %}</code></pre>

**Как это работает**

Это длинный пример, но он помогает продемонстрировать природу переменных класса и объекта. Здесь `population` принадлежит классу `Robot`, и поэтому является переменной класса. Переменная `name` принадлежит объекту (ей присваивается значение при помощи `self`), и поэтому является переменной объекта.

Таким образом, мы обращаемся к переменной класса `population` как `Robot.population`, а не `self.population`. К переменной же объекта `name` во всех методах этого объекта мы обращаемся при помощи обозначения `self.name`. Помните об этой простой разнице между переменными класса и объекта. Также имейте в виду, что переменная объекта с тем же именем, что и переменная класса, сделает недоступной ("спрячет") переменную класса!

Вместо `Robot.population` мы могли бы также использовать `self.__class__.Population`, потому что каждый объект ссылается на свой класс через атрибут `self.__class__`.

Метод `how_many` принадлежит классу, а не объекту. Это означает, что мы можем определить его как `classmethod` или `staticmethod`, в зависимости от того, нужно ли нам знать, в каком классе мы находимся. Поскольку мы ссылаемся на переменную класса, мы воспользуемся `classmethod`.

Мы пометили метод `how_many` как метод класса, использующий [декоратор](./more.md#decorator).

<pre><code class="lang-python">{% include "./programs/oop_staticmethod.py" %}</code></pre>

Декораторы можно считать неким упрощённым способом вызова явного оператора, как мы видели в этом примере.
Декораторы можно представить как ярлык для вызова функции-оболочки (т.e. функция, которая "оборачивает" другую функцию, чтобы она могла что-то делать до или после внутренней функции), поэтому применение декоратора `@classmethod` аналогично вызову:

```python
how_many = classmethod(how_many)
```

Пронаблюдайте, как метод `__init__` используется для инициализации экземпляра `Robot` с именем. В этом методе мы увеличиваем счётчик `population` на 1, так как добавляем ещё одного робота. Также заметьте, что значения `self.name` для каждого объекта свои, что указывает на природу переменных объекта.

Помните, что к переменным и методам самого объекта нужно обращаться, пользуясь *только* `self`. Это называется *доступом к атрибутам*.

В этом примере мы также наблюдали применение *строк документации* для классов, равно как и для методов. Во время выполнения мы можем обращаться к строке документации класса при помощи `Robot.__doc__`, а к строке документации метода – при помощи `Robot.say_hi.__doc__`.

В методе `die` мы просто уменьшаем `Robot.population` на 1.

Все члены класса являются публичными (public). Исключение: если имя переменной начинается с _двойного подчёркивания_, как, например, `__privatevar`, Python делает эту переменную приватной (private).

Поэтому принято имя любой переменной, которая должна использоваться только внутри класса или объекта, начинать с подчёркивания, а все остальные имена являются публичными, и могут использоваться в других классах/объектах. Помните, что это лишь соглашение и Python вовсе не обязывает делать именно так (кроме двойного подчёркивания).

> **Примечание для программистов на C++/Java/C#**
> 
> В Python все члены класса (включая данные) являются _публичными_ (public), а все методы – _виртуальными_ (virtual).

## Наследование

Одно из главных достоинств объектно-ориентированного программирования заключается в **многократном использовании** одного и того же кода, и один из способов этого достичь – при помощи механизма **наследования**. Легче всего представить себе наследование в виде отношения между классами как **тип и подтип**.

Представим, что нам нужно написать программу, которая отслеживает информацию о преподавателях и студентах в колледже. У них есть некоторые общие характеристики: имя, возраст и адрес. Есть также и специфические характеристики, такие как зарплата, курсы и отпуск для преподавателей, а также оценки и оплата за обучение для студентов.

Можно создать для них независимые классы и работать с ними, но тогда добавление какой-либо новой общей характеристики потребует добавления её к каждому из этих независимых классов в отдельности, что делает программу неповоротливой.

Лучше создать общий класс с именем `SchoolMember`, а затем сделать так, чтобы классы преподавателя и студента _наследовали_ этот класс, т.е. чтобы они стали подтипами этого типа (класса), после чего добавить любые специфические характеристики к этим подтипам.

У такого подхода есть множество достоинств. Если мы добавим/изменим какую-либо функциональность в `SchoolMember`, это автоматически отобразится и во всех подтипах. Например, мы можем добавить новое поле удостоверения для преподавателей и студентов, просто добавив его к классу `SchoolMember`. С другой стороны, изменения в подтипах никак не влияют на другие подтипы. Ещё одно достоинство состоит в том, что обращаться к объекту преподавателя или студента можно как к объекту `SchoolMember`, что может быть полезно в ряде случаев, например, для подсчёта количества человек в школе. Когда подтип может быть подставлен в любом месте, где ожидается родительский тип, т.е. объект считается экземпляром родительского класса, это называется **полиморфизмом**.

Заметьте также, что код родительского класса используется многократно, и нет необходимости копировать его во все классы, как пришлось бы в случае использования независимых классов.

Класс `SchoolMember` в этой ситуации называют **базовым классом** или **надклассом**(также "суперкласс", "родительский класс"). Классы `Teacher` и `Student` называют **производными классами** или **подклассами**(также "субкласс", "класс-наследник").

Рассмотрим теперь этот пример в виде программы (сохраните как `oop_subclass.py`):

<pre><code class="lang-python">{% include "./programs/oop_subclass.py" %}</code></pre>

Вывод:

<pre><code>{% include "./programs/oop_subclass.txt" %}</code></pre>

**Как это работает**

Чтобы воспользоваться наследованием, при определении класса мы указываем имена его базовых классов в виде кортежа, следующего сразу за его именем(например, `class Teacher(SchoolMember)`). Далее мы видим, что метод `__init__` базового класса вызывается явно при помощи переменной `self`, чтобы инициализировать часть объекта, относящуюся к базовому классу. Это очень важно запомнить: поскольку мы определяем метод `__init__` в подклассах `Teacher` и `Student`, Python не вызывает конструктор базового класса `SchoolMember` автоматически – его необходимо вызывать самостоятельно в явном виде.

Напротив, если мы не определим метод `__init__` в подклассе, Python вызовет конструктор базового класса автоматически.

Обратите внимание, что при вызове метода `tell` из класса `SchoolMember` экземпляры `Teacher` или `Student` можно использовать как экземпляры `SchoolMember`, просто набрав `Teacher.tell` или `Student.tell`. Вместо этого мы определили другой метод `tell` в каждом подклассе (используя метод `tell` класса `SchoolMember` как основу), чтобы адаптировать его для этого подкласса. Заметьте также, что вызывается метод `tell` из подкласса, а не метод `tell` из класса `SchoolMember`. 

Однако, если бы у нас не было метода `tell` в подклассе, Python использовал бы метод `tell` в надклассе. Это можно понять следующим образом: Python всегда начинает поиск методов в самом классе, что он и делает в данном случае. Если же он не находит метода, он начинает искать методы, принадлежащие базовым классам по очереди, в порядке, в котором они перечислены в кортеже (здесь у нас есть только 1 базовый класс, но у вас может быть несколько базовых классов) при определении класса.

Замечание по терминологии: если при наследовании перечислено более одного класса, это называется **множественным наследованием**.


## Резюме

Мы изучили различные аспекты классов и объектов, равно как и терминологию, связанную с ними. Мы также увидели ряд достоинств и "подводных камней" объектно-ориентированного программирования. Python – в высокой степени объектно-ориентирован, поэтому понимание этих принципов очень поможет вам в дальнейшем.

Далее мы узнаем, как работать с вводом/выводом и получать доступ к файлам в Python.
